\documentclass[justified]{tufte-book}

% uncomment this line if you prefer colored hyperlinks (e.g., for onscreen viewing)
\hypersetup{colorlinks}

% For nicely typeset tabular material
\usepackage{booktabs}

% For graphics/images
\usepackage{graphicx}
\setkeys{Gin}{width=\linewidth, totalheight=\textheight, keepaspectratio}
\graphicspath{{graphics/}}

\usepackage{amsmath}
\usepackage{units}

% Prints a trailing space in a smart way.
\usepackage{xspace}

% Generates the index
\usepackage{makeidx}
\makeindex

\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.9647,0.9647,0.9647} % {239, 240, 241}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{highlight}{RGB}{229, 239, 245}

\usepackage{soul} % for light gray highlight
\sethlcolor{highlight}

\lstset{ %
  backgroundcolor=\color{mygray},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  % frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=C++,                    % the language of the code
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=none,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

% \usepackage{hyperref} 
% \hypersetup{
%     colorlinks=true,
%     linkcolor=blue,
%     filecolor=magenta,      
%     urlcolor=cyan,
% }
% \urlstyle{same}

% Inserts a blank page
\newcommand{\blankpage}{\newpage\hbox{}\thispagestyle{empty}\newpage}

% Book metadata
\title{LeetCode Solutions}
%\author{}
%\publisher{}

% add numbered headings to level 3 title
% chapter       -- 0
% section       -- 1
% subsection    -- 2
% subsubsection -- 3
% paragraph     -- 4
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{1} % table of contents depth

\begin{document}
% Front matter
\frontmatter

\blankpage

\maketitle

% \setcounter{secnumdepth}{1}
\tableofcontents
\listoffigures
\listoftables

% Start the main matter (normal chapters)
\mainmatter
This document summarizes solutions for LeetCode problems I have solved. Many of solution ideas come from LeetCode discussion forum. By coding and writing down the solution, it really help me understand the solution instead of memorizing it.  

\chapter{Problems by Category}
\section{Binary Search}
\subsection{Basics}
\begin{itemize}
    \item sqrt vs. square
    \begin{itemize}
        \item \hyperref[sec:lc69_sqrt]{LC69 - sqrt(x)}
        \item \hyperref[sec:lc367_valid_perfect_square]{LC367 - Valid Perfect Square}
    \end{itemize}
\end{itemize}

\subsection{Advanced}
\begin{itemize}
    \item Rotated sorted array
    \begin{itemize}
        \item \hyperref[sec:lc33_search_rotated_sorted_array]{LC33 - Search in Rotated Sorted Array}
        \item \hyperref[sec:lc81_search_rotated_sorted_array_ii]{LC81 - Search in Rotated Sorted Array II}
        \item \hyperref[sec:lc153_find_min_rotated_sorted_array]{LC153 - Find Minimum in Rotated Sorted Array}
        \item \hyperref[sec:lc154_find_min_rotated_sorted_array_ii]{LC154 - Find Minimum in Rotated Sorted Array II}
    \end{itemize}
    
    \item Transform the problem
    \begin{itemize}
        \item \hyperref[sec:lc540_single_element_sorted_array]{LC540 - Single Element in a Sorted Array}
        \item \hyperref[sec:lc875_koko_eat_banana]{LC875 - Koko Eat Bananas}
    \end{itemize}
    
\end{itemize}

\section{Array}
\subsection{Two Pointers}

\section{Linked List}

\chapter{Solutions}
% \section{LC287 - Find the Duplicate Number}
% \subsection{Problem Description}
% \href{https://leetcode.com/problems/find-the-duplicate-number/}{LeetCode Problem 287}: Given an array of integers nums containing $n + 1$ integers where each integer is in the range $[1,\, n]$ inclusive. There is only \textbf{one duplicate number} in nums, return this duplicate number. \\

% \subsection{Analysis}

% \subsection{Approach 1 - }
% \textbf{Complexity Analysis}

% \subsection{Comparison of Different Approaches}
% \begin{table}[ht]
%   \centering
%   \begin{tabular}{p{5cm}ll}
%     \toprule
%     Approach & Time Complexity & Space Complexity \\
%     \midrule
%     Approach 1 - Binary Search &  $\mathcal{O}(n\log n)$ & $\mathcal{O}(1)$\\
%     Approach 2 - Sort \& Search &  $\mathcal{O}(n \log{n})$ & $\mathcal{O}(1)$\\
%     \bottomrule
%   \end{tabular}
%   % \caption{Notation.}
%   % \label{tab:application_guide}
% \end{table}

\section{LC33 - Search in Rotated Sorted Array} \label{sec:lc33_search_rotated_sorted_array}
\subsection{Problem Description}
\href{https://leetcode.com/problems/search-in-rotated-sorted-array/}{LeetCode Problem 33}: You are given an integer array nums sorted in ascending order (with \textbf{distinct} values), and an integer target.

Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., $[0,1,2,4,5,6,7]$ might become $[4,5,6,7,0,1,2]$).

If target is found in the array return its index, otherwise, return -1.

\subsection{Approach - Binary Search}
The original array is sorted in ascending order and then rotated at some pivot. So the array can be always divided into two parts: one part is sorted and the other part is unsorted, containing the pivot. It is easy to check whether the target is in the sorted part and search inside that part. If the target is in the unsorted part, we can further divide the unsorted part into two parts (again one part will be sorted and the other will be unsorted) and continue to check the sorted part. This allow us using binary search to find the target. 

The search space starts from the whole array and shrinks over each iteration, using [left, right] to indicate the search space. The mid is the separation point to divide the search space into two parts, one is sorted and the other is unsorted.   
\begin{itemize}
    \item If $\text{nums[left]} \leq \text{nums[mid]}$, the sub-array [left, mid] is sorted \sidenote{This is true when an array contains distinct values, i.e., no duplicates.}. \\
    It is easy to check whether the target is inside this part. If not, continue to divide and search the right half.
    \item If $\text{nums[left]} > \text{nums[mid]}$, the right sub-array [mid, right] is sorted. \\
    We can check whether the target is in the right part. If not, continue to divide and search the left half.
\end{itemize}

\begin{lstlisting}
int search(vector<int>& nums, int target) {
    if (nums.empty()) return -1;
    
    int left = 0;
    int right = nums.size() - 1;
    int mid; 
    
    while (left <= right) {
        mid = left + (right - left)/2;
        
        if (target == nums[mid]) {
                return mid;
            }
        else if (nums[left] <= nums[mid]) {
            // [left, mid] is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }
        else {
            // [mid, right] is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
    }
    
    return -1;
}           
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    Since using binary search, the time complexity is $\mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables for binary search.
\end{itemize}

\section{LC34 - Find First and Last Position of Element in Sorted Array} \label{sec:lc34_find_first_last_position_sorted_array}

\section{LC35 - Search Insert Position} \label{sec:lc35_search_insert_position}
\subsection{Problem Description}
\href{https://leetcode.com/problems/search-insert-position/}{LeetCode Problem 35}: Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. The array contains \textbf{distinct} values sorted in ascending order. 

\subsection{Approach - Binary Search}
Since the array is sorted, the problem can be solved by using Binary Search. The key part is to understand what is searching for. Here is the insert position (not the target). \sidenote{\href{https://leetcode.com/problems/search-insert-position/discuss/249092/Come-on-forget-the-binary-search-patterntemplate!-Try-understand-it!}{@Zhengguan Li} gives some good explanations.} The Search range is the range of array, $[0, n-1]$. 
\begin{itemize}
    \item If \hl{nums[mid] == target}, return mid
    \item If \hl{target > nums[mid]}, mid is not the potential insert position while mid + 1 is.  so \hl{left = mid + 1}.
    \item If \hl{target < nums[mid]}, mid is the potential insert position and \hl{right = mid};
\end{itemize}
To determine the while loop condition, we can use two-element case to test our left/right operations: 1) \hl{left = mid + 1} and 2) \hl{right = mid}. We can see that it can be safely reduced to one element but not zero. So we need end the while loop when there is only one element left, i.e., \hl{while(left < right)}. 
\begin{lstlisting}
index:      [0,    1]
2 elements: [5,    7]
            l/m    r
1 element:  l/m/r        
or:               l/m/r            
\end{lstlisting}
After while loop, we need to check the remaining one element: \hl{nums[left]} with \hl{left == right}, which has not been checked in binary search loop. 
\begin{lstlisting}
int searchInsert(vector<int>& nums, int target) {
    if (nums.empty()) {
        return -1;
    }
    
    int left = 0;
    int right = nums.size() - 1;
    int mid;
    
    while (left < right) {
        mid = left + (right - left)/2;
        
        if (target == nums[mid]) {
            return mid;
        }
        else if (target > nums[mid]) {
            left = mid + 1;  // mid is not the insert position but mid + 1 can be the potential insert position.
        }
        else {
            right = mid; // mid can be the insert position
        }
    }
    
    // 1 element left at the end
    // post-processing
    return nums[left] < target ? left + 1 : left;
}
\end{lstlisting}

\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    Since using binary search, the time complexity is $\mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables for binary search.
\end{itemize}

\section{LC69 - Sqrt(x)} \label{sec:lc69_sqrt}
\subsection{Problem Description}
\href{https://leetcode.com/problems/sqrtx/}{LeetCode Problem 69}: Given a non-negative integer $x$, compute and return the square root of $x$.
Since the return type is an integer, the decimal digits are \textbf{truncated}, and only \textbf{the integer part} of the result is returned.

\subsection{Approach - Binary Search}
Mathematically, $i = sqrt(x)$ can be viewed as $x = i*i$. The problem is to find an integer $i$ in the search space $[1, x]$ \sidenote{The search space could be $[1, x/2]$ for $x>=4$. Yet, it just saves one iteration if using binary search.} such that $i*i <= x$ and $(i+1)*(i+1) > x$. If $i*i > x$, we can exclude values larger than $i$. If $i*i < x$, we can exclude the value smaller than $i$. With this property, we can solve this problem using binary search. There are three potential issues:
\begin{itemize}
    \item corner case: $x <= 1$;
    \item overflow caused by $i*i$ in the evaluation $i*i > x$;
    \item can not simply check $i == x/i$ to determine whether the answer is found since there may be multiple values satisfied this equations due to integer division.
\end{itemize}

\begin{lstlisting}
int mySqrt(int x) {
    if (x <= 1) {
        return x;
    }

    int left = 1;
    int right = x;
    int mid;

    while (left <= right) {
        mid = left + (right - left)/2;

        if ((mid <= x/mid) && ((mid + 1) > x/(mid + 1))) {
            return mid;
        }
        else if (mid > x/mid) {
            right = mid - 1;
        }
        else {
            left = mid + 1; 
        }
    }
    return -1;
}
\end{lstlisting}

\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    Since using binary search, the time complexity is $\mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited constant variables for binary search.
\end{itemize}

\section{LC70 - Climbing Stairs} \label{sec:lc70_climb_stair}
\subsection{Problem Description}
\href{https://leetcode.com/problems/climbing-stairs/}{LeetCode Problem 70}: You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 

\subsection{Approach - Dynamic Programming}
Use dynamic programming to solve this problem. One can reach $i$-th step in one of two ways:
\begin{enumerate}
    \item Taking a step of $1$ from $(i-1)$th step.
    \item Taking a step of $2$ from $(i-2)$th step.
\end{enumerate}
The total number of distinct ways to reach $i$th step is the sum of ways of reaching $(i-1)$th step and ways of reaching $(i-2)$th step. Let $f(i)$ denotes the number of distinct ways to reach $i$th step, then we have $f(i) = f(i-1) + f(i-2)$. This becomes a problem of finding $i$th number of the Fibonacci series with base cases $f(1) = 1$ and $f(2) = 2$. Check \hyperref[sec:lc509_fibonacci]{LC509 Fibonacci Number} for detailed solutions.

\section{LC81 - Search in Rotated Sorted Array II} \label{sec:lc81_search_rotated_sorted_array_ii}
\subsection{Problem Description}
\href{https://leetcode.com/problems/search-in-rotated-sorted-array-ii/}{LeetCode Problem 81}: You are given an integer array nums sorted in ascending order (not necessarily distinct values), and an integer target.

Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., $[0,1,2,4,4,4,5,6,6,7]$ might become $[4,5,6,6,7,0,1,2,4,4]$).

If target is found in the array return true, otherwise, return false.

\subsection{Approach - Binary Search}
This is a follow-up problem to \hyperref[sec:lc33_search_rotated_sorted_array]{LC33 - Search in Rotated Sorted Array}. The difference is that it contains duplicates. Due to duplicates, when $\text{nums[left]} == \text{nums[mid]}$, we don't know whether which part (left or right) is sorted. For example, $[3, 1, 3, 3, 3, 3, 3]$ with left part unsorted and $[3, 3, 3, 3, 3, 1, 3]$ with right part unsorted. For this case, if target != nums[mid], we can increase left by one, i.e., \hl{left++}.   

\begin{lstlisting}
bool search(vector<int>& nums, int target) {
    if (nums.empty()) return false;
    
    int left = 0;
    int right = nums.size() - 1;
    int mid;
    
    while (left <= right) {
        mid = left + (right - left)/2;
        
        if (target == nums[mid]) {
            return true;
        }
        else if (nums[left] < nums[mid]) {
            // [left, mid] is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            }
            else {
                left = mid + 1;
            }
        }
        else if (nums[left] == nums[mid]) { // handle corner case with duplicates
            left++;
        }
        else {
            // [mid, right] is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
    }
    
    return false;
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ for the average case and  $\mathcal{O}(n)$ for the worse case\\
    In the worst case, just move left pointer by one, which needs $n$ steps. So the time complexity is $\mathcal{O}(n)$. For the average case, since using binary search, the time complexity is $\mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables for indices.
\end{itemize}

\section{LC88 - Merge Sorted Array} \label{sec:lc88_merge_sorted_array}
\subsection{Problem Description}
\href{https://leetcode.com/problems/merge-sorted-array/}{LeetCode Problem 88}: Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

The number of elements initialized in nums1 and nums2 are $m$ and $n$ respectively. You may assume that nums1 has enough space (size that is equal to $m + n$) to hold additional elements from nums2.

\subsection{Approach - Two Pointers}
The problem is similar to the merge function of merge sort. The differences are: 1) no need to create a new auxiliary array to store the combined sorted array; 2) move pointers from right to left. For this type of problem, we can use two pointers for each array and move the pointers based on the comparison result between two arrays. Moreover, we need to consider the pointer out of bound cases since the array size may be different. 

\begin{lstlisting}
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    int i = m - 1; // pointer for nums 1, scan from right to left
    int j = n - 1; // pointer for nums 2, scan from right to left
    int k = m + n - 1; // poionter for temp array
    
    //    0  1  2  3  4  5
    //   [1, 2, 2, 3, 5, 6]
    //    i/k 
    //   [2, 5, 6]
    //  j
    
    while (k >= 0) {
        if (i < 0) {
            nums1[k--] = nums2[j--];
        }
        else if (j < 0) {
            nums1[k--] = nums1[i--];
        }
        else if (nums1[i] >= nums2[j]) {
            nums1[k--] = nums1[i--];
        }
        else {
            nums1[k--] = nums2[j--];
        }
    }
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(m + n)$ \\
    Since it will scan all elements in nums1 and nums2, the time complexity is the total size of two arrays, i.e., $\mathcal{O}(m + n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables for indices.
\end{itemize}

\section{LC153 - Find Minimum in Rotated Sorted Array} \label{sec:lc153_find_min_rotated_sorted_array}
\subsection{Problem Description}
\href{https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/}{LeetCode Problem 153}: Suppose an array of length $n$ sorted in ascending order is rotated between $1$ and $n$ times. For example, the array $\text{nums} = [0,1,2,4,5,6,7]$ might become: $[4,5,6,7,0,1,2]$ if it was rotated 4 times, or $[0,1,2,4,5,6,7]$ if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] $1$ time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array nums, return the minimum element of this array. All the integers of nums are \textbf{unique}.

\subsection{Approach - Binary Search}
Since the array is originally sorted and rotated between $1$ and $n$ times, there will be two potential forms after rotations:
\begin{itemize}
    \item The whole array is sorted in the ascending order (i.e., the array rotates back to the original one );
    \item There is a pivot point in the array, which separate the array into two halves: one half is sorted and the other is not sorted.
\end{itemize}
So if we can detect which half is not sorted, we know that the minimum value should be in that unsorted half and ignore the sorted half. If both halves are sorted, the first left element is the minimum. If we split the array into two halves, $[\text{left}, \text{mid}]$ and $[\text{mid} + 1, \text{right}]$, there are $4$ kings of relationship among nums[left], nums[mid], and nums[right]:
\begin{enumerate}
    \item $\text{nums[left]} \leq \text{nums[mid]} \leq \text{nums[right]}$ \\
    min is nums[left]
    \item $\text{nums[left]} > \text{nums[mid]} \leq \text{nums[right]}$ \\
    \text{[left, mid]} is not sorted and min is inside the left half
    \item $\text{nums[left]} <= \text{nums[mid]} > \text{nums[right]}$ \\
    \text{[mid+1, right]} is not sorted and min is inside the right half
    \item $\text{nums[left]} > \text{nums[mid]} > \text{nums[right]}$ \\
    Impossible, since the original array is sorted in ascending order
\end{enumerate}
So we can check nums[mid] and nums[right] \sidenote{If we just check nums[left] and nums[mid], the condition $\text{nums[left]} <= \text{nums[mid]}$ can't distinguish relationship $1$ and $3$ which requires searching two different directions. This requires special consideration on 1) the whole array is sorted or 2) not falling into the subset subset of an array that is sorted when update left and right indices (e.g., $[0, 1, 2]$ of $[4, 5, 6, 7, 0, 1, 2]$).}: 
\begin{itemize}
    \item If $\text{nums[mid]} > \text{nums[right]}$, search the right half \\
    This covers relationship $3$.
    \item If $\text{nums[mid]} \leq \text{nums[right]}$, search the left half \\
    This covers relationship $1$ and $2$, since in both cases the minimum is on the left.
\end{itemize}

\begin{lstlisting}
int findMin(vector<int>& nums) {
    int left = 0; 
    int right = nums.size() - 1;
    int mid;
    
    while (left < right) {
        mid = left + (right - left)/2;
        
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        else {
            right = mid;
        }
    }
    
    // Post-processing
    return nums[left];
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    Since using binary search, the time complexity is $\mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited constant variables for binary search.
\end{itemize}

\section{LC154 - Find Minimum in Rotated Sorted Array II} \label{sec:lc154_find_min_rotated_sorted_array_ii}
\subsection{Problem Description}
\href{https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/}{LeetCode Problem 154}: Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand (e.g.,  $[0,1,2,4,5,6,7]$ might become $[4,5,6,7,0,1,2]$). Find the minimum element. The array may \textbf{contain duplicates}. 

This is a follow up problem to \hyperref[sec:lc153_find_min_rotated_sorted_array]{LC153 - Find Minimum in Rotated Sorted Array}.

\subsection{Approach - Binary Search}
The big difference between this problem and LC153 is that \textbf{the array may contain duplicates}. So when $\text{nums[mid]} == \text{nums[right]}$, the position of minimum could be in either left or right of mid (e.g., $[3, 3, 3, 3, 1, 3]$, or $[3, 1, 3, 3, 3, 3]$). So
\begin{itemize}
    \item For relationship $1$, $\text{nums[left]} \leq \text{nums[mid]} \leq \text{nums[right]}$, the min is not necessariely on the left and could be anywhere when $\text{nums[left]} == \text{nums[mid]} == \text{nums[right]}$.
    \item For relationship $2$, $\text{nums[left]} > \text{nums[mid]} \leq \text{nums[right]}$, when $\text{nums[mid]} == \text{nums[right]}$, min could be in either left or right of mid.
\end{itemize}

\begin{lstlisting}
int findMin(vector<int>& nums) {
    int left = 0;
    int right = nums.size() - 1;
    int mid; 
    //  0  1  2  3  4
    // [2, 0, 1, 1, 1]
    //  l     m     r
    
    while (left < right) {
        mid = left + (right - left)/2;
        
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        else if (nums[mid] < nums[right]) {
            right = mid;
        }
        else { // nums[mid] == nums[right], main difference
            right--;
        }
    }
    
    return nums[left];
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(n)$ (worst case) and $\mathcal{O}(\log n)$ (average case) \\
    In the worst case, it searches one element at a time and takes $\mathcal{O}(n)$ time. For the average case, the time complexity is $\mathcal{O}(\log n)$ with the binary search.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables.
\end{itemize}


\section{LC240 - Search a 2D Matrix II} \label{sec:lc240_search_2d_matrix_ii}

\section{LC275  - H-Index II} \label{sec:lc275_h_index_ii}
\subsection{Problem Description}
\href{https://leetcode.com/problems/h-index-ii/}{LeetCode Problem 275}: Given an array of citations \textbf{sorted in ascending order} (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the \href{https://en.wikipedia.org/wiki/H-index}{definition of h-index on Wikipedia}: ``A scientist has index $h$ if $h$ of his/her $N$ papers have at least $h$ citations each, and the other $N - h$ papers have no more than $h$ citations each.'' 

If there are several possible values for $h$, the maximum one is taken as the $h$-index.

\subsection{Approach - Binary Search}
Based on the definition on Wikipedia, for the citation sorted in \textbf{descending} order, H-Index is to find the \textbf{last} position where citation is greater than or equal to the position. In this problem, the citation array is sorted in \textbf{ascending} order. H-Index is to find the first position/index where 
\begin{equation} 
    \text{citations[index]} >= n - \text{index} \label{eq:h_index}
\end{equation}
Where $n$ is the total number of papers (i.e., length of citation array). Note that we may not find the exact solution. So the above equation changes from $\geq$ to $>$. There are two important properties associated with H-Index definitions:
\begin{itemize}
    \item If index $i$ satisfies Eq. \ref{eq:h_index}, then any index $j$ that is larger than index $i$ will also satisfy the equation. \\
    We know $n - i > n - j$ due to $j > i$. Since the citation is in ascending order, we have $\text{citations}[j] >= \text{citations}[i]$. Together with Eq. \ref{eq:h_index}, we can obtain
    \begin{eqnarray*}
        \text{citations}[j] >= \text{citations}[i] >= n - i > n - j
    \end{eqnarray*}
    which satisfies Eq. \ref{eq:h_index}.
    \item If we find the exact solution (i.e., $        \text{citations}[i] == n - i$), that's the only solution.
    \begin{itemize}
        \item For $j > i$, based on the previous property, we know $\text{citations}[j] > n - j$, which is $>$ not $==$
        \item For $j < i$, we can obtain $        \text{citations}[j] <= \text{citations}[i] == n - i < n - j$, which is $<$ not $==$
    \end{itemize}
\end{itemize}
With above mentioned properties, we can use binary search to reach search space each iteration. 
\begin{lstlisting}
int hIndex(vector<int>& citations) {
    if (citations.empty()) return 0;
    
    int n = citations.size();
    int left = 0;
    int right = n - 1;  
    int mid;
    int value;
    
    // [x, y]
    // l/m r
    while (left < right) {
        mid = left + (right - left)/2;
        value = citations[mid];
        
        if (value == n - mid) {
            // find the solution
            return n - mid;
        }
        else if (value > n - mid) {
            right = mid; // mid qualified as h-index and continue to search left for a higher one; no mid -1 since exact solution may not exist
        }
        else {
            left = mid + 1;
        }
    }
    
    // post-processing: left == right
    return (citations[right] >= n - right) ? (n - right) : 0;   
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$\\
    The time complexity is $\mathcal{O}(\log n)$ with the binary search.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables.
\end{itemize}

\section{LC278 - First Bad Version} \label{sec:lc278_first_bad_version}
\subsection{Problem Description}
\href{https://leetcode.com/problems/first-bad-version/}{LeetCode Problem 278}: You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have $n$ versions $[1, 2, ..., n]$ and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API \hl{bool isBadVersion(version)} which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

\subsection{Approach - Binary Search}
Each version has its corresponding status:
\begin{eqnarray*}
    \text{versions} ~ &:& \begin{bmatrix} 1 & 2 & \cdots & i & i+1 & \cdots & n \end{bmatrix} \\
    \text{status} ~ &:& \begin{bmatrix} G & G & \cdots & G & B & \cdots & B \end{bmatrix}
\end{eqnarray*}
The problem can be solved using binary search to find the first bad status. Similar to problem \hyperref[sec:lc34_find_first_last_position_sorted_array]{LC34 Find First and Last Position of Element in Sorted Array}.

\section{LC287 - Find the Duplicate Number} \label{sec:lc287_find_duplicate_number}
\subsection{Problem Description}
\href{https://leetcode.com/problems/find-the-duplicate-number/}{LeetCode Problem 287}: Given an array of integers nums containing $n + 1$ integers where each integer is in the range $[1, n]$ inclusive. There is only \textbf{one duplicate number} in nums, return this duplicate number. 

\noindent \textbf{Constraints:}
\begin{itemize}
    \item $2 \leq n \leq 3*10^4$
    \item $\text{nums.length} == n + 1$
    \item $1 \leq nums[i] \leq n$
    \item All the integers in nums appear only \textbf{once} except for \textbf{precisely one integer} which appears two or more times.
\end{itemize} 

\noindent \textbf{Follow-ups:}
\begin{itemize}
    \item How can we prove that at least one duplicate number must exist in nums?\\
    Based on pigeonhole principle \sidenote{\href{https://en.wikipedia.org/wiki/Pigeonhole_principle}{Pigeonhole principle}: if $n$ items are put into $m$ containers, with $n > m$, then at least one container must contain more than one item. Note that it \textbf{doesn't} tell you there \textbf{isn't} a duplicate if there aren't too many items, $n <= m$.}, at least one duplicate number must exist in nums. We can also use contradiction method. 
    \item Can you solve the problem \textbf{without} modifying the array nums? \\
    In approach 2, the sort method requires modifying the array nums. Simply fix is to copy array nums, which will require $\mathcal{O}(n)$ space. 
    \item Can you solve the problem using only constant, $\mathcal{O}(1)$ extra space?
    \item Can you solve the problem with runtime complexity less than $\mathcal{O}(n^2)$?
    \item \textbf{My follow-up:} Can you solve the problem with more than one duplicate number? \\
    Only approach 3 using set can work. 
    \item \textbf{My follow-up:} what if there is a missing number? \\
    Approach 2 using sort and binary search won't work.
\end{itemize}

\subsection{Approach 1 - Binary Search}
We know that the search space of the duplicate number is between 1 to n (inclusive, $[1, n]$). For a given number $x$ in the search space $[1, n]$, go through array nums and count all the numbers in the range $[1, x]$ which is denoted as count. If $count > x$, then there are more than $x$ elements in the range $[1, x]$ and thus that range contains a duplicate based on pigeonhole principle. If $count <= x$, then there are $n + 1 - count$ elements (array size is $n+1$) in the range $[x+1, n]$. That is, \textbf{at least} $n + 1 - x$ elements in a range of size $n - x$, where $n + 1 - count \geq n + 1 - x > n - x$ . Thus this range must contains a duplicate. \sidenote{Simple explanation: the whole range is ``too crowded'' and so either the first or the second half of the range is too crowded. If the first half is too crowded, then it contains a duplicate. Otherwise, the second half contains a duplicate.} With this property, we can use binary search idea to reduce search space by half after each iteration until search space is only one number.  

\begin{lstlisting}
int findDuplicate(vector<int>& nums) {
    int left = 1;
    int right = nums.size() - 1;
    int mid;
    int count = 0;
    
    while (left < right) {
        mid = left + (right - left)/2;
        count = 0;
        for(int num:nums) {
            count += num <= mid;
        }
        
        count > mid ? right = mid : left = mid + 1;
    }
    
    return left;
}
\end{lstlisting}

\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(n\log n)$ \\
    Since using binary search, it takes $\mathcal{O}(\log n)$ steps. For each iteration, it will go through the whole array to count the number, which takes $\mathcal{O}(n)$ time. So the time complexity is $\mathcal{O}(n\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables for binary search and count.
\end{itemize}

\subsection{Approach 2 - Sort \& Search}
If the array is sorted, we can do the search on the sorted array. The sorted array has the following properties:
\begin{itemize}
    \item Any duplicate numbers will be adjacent in the sorted array \\
    Simply compare each element to its previous element. If they are equal, return the element. 
    \item \textbf{If no missing number} in the range $[1, n]$, the difference between the element value and its corresponding index will be reduced by 1 when encountering the duplicate. \\
    The difference is $[x, x, \cdots, x, x-1, \cdots, x-1]$. We can use the binary search to find the last element of $x$. \textbf{Note} the substraction is only conducted on the mid indices not all elements in the array. 
\end{itemize}

\begin{lstlisting}
int findDuplicate(vector<int>& nums) {
    // sort array
    sort(nums.begin(), nums.end()); 
    
    // option 1: compare previous element
    // for (vector<int>::size_type i = 1; i != nums.size(); i++) {
    //    if (nums[i] == nums[i-1]) {
    //        return nums[i];
    //    }
    // }
    
    // option 2: binary search
    int left = 0;
    int right = nums.size() - 1;
    int mid;
    int diff;
    int target = 0 - nums[0]; // target is the difference bewteen first value and its index
    
    // Use binary search to find the last target in a ascending order 
    // [e, e, ..., e, s, s, ...]
    while (left < right - 1) {
        mid = left + (right - left)/2;
        diff = mid - nums[mid];
        
        if (target == diff) {
            left = mid;
        }
        else if (target > diff) {
            left = mid + 1; 
        }
        else {
            right = mid - 1; // not mid - 1, since it may accidently exclude the final solution
        }
    }
    
    // two elements left after while loop left == right - 1
    return nums[right];  
}  
\end{lstlisting}

\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(n\log n)$ \\
    There are two steps:the first step using sort algorithm takes $\mathcal{O}(n\log n)$; The second step takes $\mathcal{O}(n)$ if comparing with previous element or $\mathcal{O}(\log n)$ if using binary search.  So the total time complexity is $\mathcal{O}(n\log n)$, $\mathcal{O}(n\log n)= \mathcal{O}(n\log n) + \mathcal{O}(n)$ or $\mathcal{O}(n\log n) = \mathcal{O}(n\log n) + \mathcal{O}(\log n)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ (or $\mathcal{O}(n)$) \\
    The sort is in-place and only use limited variables for search after sorting. So the space complexity is $\mathcal{O}(1)$. If we cannot modify the input array, then we must allocate linear space $\mathcal{O}(n)$ for a copy of array and sort that instead.
\end{itemize}

\subsection{Approach 3 - Set}
Store unique element when iterating over the array and check whether element is already stored. We can use \href{http://www.cplusplus.com/reference/unordered_set/unordered_set/}{unordered\_set} container in C++ standard library, which on average has constant time complexity on inserting and looking up an element. 
\begin{lstlisting}
int findDuplicate(vector<int>& nums) {
    unordered_set<int> seen;
    
    for (int num:nums) {
        if (seen.count(num)) {
            return num;
        }
        else
        {
            seen.insert(num);
        }
    }
    
    return -1; 
}  
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(n)$ for average case, $\mathcal{O}(n^2)$ for worst case\\
    It takes $\mathcal{O}(n)$ to go through each element in the array. For inserting or looking up a element in a unordered set, it takes $\mathcal{O}(1)$ for average case or takes $\mathcal{O}(n)$ for the worst case. So the total time complexity is $\mathcal{O}(n)$ for average case and $\mathcal{O}(n^2)$ for worst case, 
    \item \textbf{Space complexity}: $\mathcal{O}(n)$ \\
    In the worst case, it needs $\mathcal{O}(n)$ space to store n unique elements. 
\end{itemize}

\subsection{Comparison of Different Approaches}
The table below summarizes the time complexity and space complexity of different approaches:
\begin{table}[ht]
  \centering
  \begin{tabular}{p{5cm}ll}
    \toprule
    Approach & Time Complexity & Space Complexity \\
    \midrule
    Approach 1 - Binary Search &  $\mathcal{O}(n\log n)$ & $\mathcal{O}(1)$\\
    Approach 2 - Sort \& Search &  $\mathcal{O}(n \log{n})$ & $\mathcal{O}(1)$ or $\mathcal{O}(n)$\\
    Approach 2 - Set &  $\mathcal{O}(n)$ or $\mathcal{O}(n^2)$ & $\mathcal{O}(n)$\\
    \bottomrule
  \end{tabular}
  % \caption{Notation.}
  % \label{tab:application_guide}
\end{table}

\section{LC367 - Valid Perfect Square} \label{sec:lc367_valid_perfect_square}
\subsection{Problem Description}
\href{https://leetcode.com/problems/valid-perfect-square/}{LeetCode Problem 367}: Given a positive integer num, write a function which returns True if num is a perfect square else False.

\textbf{Follow up}: Do not use any built-in library function such as sqrt.

\subsection{Approach - Binary}
The problem can be transformed to find an integer $i$ in the search space $[1, num]$ such that $i*i$ == num \sidenote{Corner case: integer overflow when doing $i*i$. Two fixes: 1) use long int; 2) or change multiplication to division.}. 
\begin{itemize}
    \item If $i*i > \text{num}$, no need to search right (i.e., $i+1$, $i+2$, $\cdots$), since square of these values will also be larger than num.
    \item If $i*i < \text{num}$, no need to search left, since square of these values will also be smaller than num.
    \item If $i*i == \text{num}$, find the answer
\end{itemize}
With these properties, we can use binary search. Due to potential overflow of using $i*i == num$, we convert it into integer division $i == num/i$. In order to check the equality of integer division, we need to check both division ($i == num/i$) and reminder ($num\%i == 0$) since multiple integers may satisfy the equality condition $i == num/i$ (e.g., $3 == 9/3, 3 == 10/3$).

\begin{lstlisting}
bool isPerfectSquare(int num) {
    if (num <= 0) return false;
    
    int left = 1;
    int right = num;
    int mid;
    int res;
    int remain;
    
    while (left <= right) {
        mid = left + (right - left)/2;
        res = num / mid; // avoid overflow mid*mid
        remain = num % mid;
        
        if (res == mid && remain == 0) {
            return true;
        }
        else if (res < mid) {
            right = mid - 1;
        }
        else {
            left = mid + 1;
        }
    }
    
    return false;
}
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    The time complexity is $\mathcal{O}(\log n)$ with the binary search.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables.
\end{itemize}


\section{LC374 - Guess Number Higher or Lower} 
\subsection{Problem Description}
\href{https://leetcode.com/problems/guess-number-higher-or-lower/}{LeetCode Problem 374}: We are playing the Guess Game. The game is as follows: I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.

\subsection{Approach - Binary}
The problem is to find the picked number in the search space $[1, n]$, which can be solved efficient by classic binary search.

\section{LC509 - Fibonacci Number} \label{sec:lc509_fibonacci}
\subsection{Problem Description}
\href{https://leetcode.com/problems/fibonacci-number/}{LeetCode Problem 509}: The Fibonacci numbers, commonly denoted $F(n)$ form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from $0$ and $1$. That is,
\begin{eqnarray*}
    F(0) &=& 0,~ F(1) = 1 \\
    F(n) &=& F(n-1) + F(n-2), ~ \text{for}~ n > 1
\end{eqnarray*}
Given $n$, calculate $F(n)$.

\section{LC540 - Single Element in a Sorted Array} \label{sec:lc540_single_element_sorted_array}
\subsection{Problem Description}
\href{https://leetcode.com/problems/single-element-in-a-sorted-array/}{LeetCode Problem 540}:You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.

\textbf{Follow up}: Your solution should run in O(log n) time and O(1) space.

\subsection{Approach - Binary Search}
The array is sorted with most elements appear \textbf{exactly twice} except for one element \sidenote{The total number is odd and the last index is even with zero-based indexing. The target element can only appear in even index of nums, i.e., nums[0], nums[2], ...}. So we can search array in pairs (two elements), i.e., $[2i, 2i-1]$. For any given pair, if elements in a pair are the same, it means the single element is on the right. Otherwise, the single element is either in this pair or on the left. With this property, we can use binary search to speed up the search. The search space is the pair index, i.e., $[0, n/2]$. We want to find the first even-index number not followed by the same number \sidenote{Note that the last pair only has one element. In the code, the while condition is \hl{left < right}, which prevents out-of-bound accesse using nums[2*mid + 1]. When it reaches the last pair, $left == right$ and it will jump out of the while loop.}.

\begin{lstlisting}
int singleNonDuplicate(vector<int>& nums) {
    if (nums.empty()) return -1;
    
    int left = 0;
    int right = nums.size()/2;  // pair index
    int mid;
    
    while (left < right) {
        mid = left + (right - left)/2;
        
        if (nums[2*mid] == nums[2*mid + 1]) {
            left = mid + 1;
        }
        else {
            right = mid;
        }
    }
    
    return nums[2*left];
}
\end{lstlisting}

\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(\log n)$ \\
    The time complexity is $\mathcal{O}(\log n)$ with the binary search.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use limited variables.
\end{itemize}

\section{LC875 - Koko Eating Bananas} \label{sec:lc875_koko_eat_banana}
\subsection{Problem Description}
\href{https://leetcode.com/problems/koko-eating-bananas/}{LeetCode Problem 875}: Koko loves to eat bananas.  There are $N$ piles of bananas, the $i$-th pile has piles[i] bananas.  The guards have gone and will come back in H hours.

Koko can decide her bananas-per-hour eating speed of $K$.  Each hour, she chooses some pile of bananas, and eats $K$ bananas from that pile.  If the pile has less than $K$ bananas, she eats all of them instead, and won't eat any more bananas during this hour.

Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back.

Return the minimum integer $K$ such that she can eat all the bananas within $H$ hours. \\

\noindent \textbf{Constraints:}
\begin{itemize}
    \item $1 \leq \text{piles.length} \leq 10^4$
    \item $\text{piles.lenght} \leq H \leq 10^9$
    \item $1 \leq \text{piles}[i] \leq 10^9$
\end{itemize} 

\subsection{Approach - Binary Search}
The difficult part of this problem is how to convert it into classic binary search problem. Based on the problem description, we can define the search space of $K$ is between $1$ and the max number of bananas $M$ on a pile, $[1, M]$. \sidenote{Since Koko likes to eat slowly, we need to start from $1$ (not zero, since Koko still wants to eat; not minimum number of bananas, since Koko could eat as slow as $1$ banana if $H > \text{total number of bananas}$). If $K >= M$, Koko can finish eating all the bananas in $N$ hours (each hour eat one pile with total $N$ piles).} Each value in the search space has a status associated with it (let N denotes not finish eating and Y denotes finish eating). Then we have $[N, N, \cdots, N, Y, \cdots, Y]$. For given $K$, 
\begin{itemize}
    \item If Koko can finish eating, no need to check $k+1, k+2, ...$ since Koko can finish eating with \textbf{bigger} numbers.
    \item If Koko can't finish eating, no need to check $k-1, k-2, ...$ since koko can \textbf{NOT} finish eating with \textbf{smaller} numbers. 
\end{itemize}
Based on this property, we can use binary search to reduce search space after each iteration until only one element left. Assume there always existing $K$ such that Koko can finish eating within $H$ hours. We also need to create help functions on checking whether Koko can finish eating. \sidenote{A nice way to round up integer values: $x/y + (x\%y == 0\, ?\, 0 : 1)$.}.

\begin{lstlisting}
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int H) {
        if (piles.empty() || (H < piles.size())) {
            return -1;
        }
        
        int lo = 1; // minmum is 1 not zero since eat at least 1 banana
        // int hi = *max_element(piles.begin(), piles.end()); //max element of the piles. Require * since max_element returns an iterator; time complexity O(N)
        // int hi = BIG_FIXED_VALUE
        int hi = getMaxPile(piles);
        
        int mid;
       
        // time complexity: O(logM)
        while (lo < hi) {
            mid = lo + (hi - lo)/2;
            
            if (canEatAll(piles, H, mid)) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        
        // lo == hi after while loop
        return lo;
    }
private:
    // time complexity: O(N)
    bool canEatAll(vector<int>& piles, int H, int k) {
        int actualHour = 0;
        
        // for (vector<int>::iterator it = piles.begin(); it != piles.end(); ++it) {*it}
        // for(vector<int>::size_type i = 0; i != piles.size(); ++i) {piles[i]}
        for(int pile:piles) {
            actualHour += pile/k + (pile%k == 0 ? 0 : 1); // round to the larger integer value 
        }
        
        return actualHour <= H;
    }
    
    int getMaxPile(vector<int>& piles) {
        int maxPile = piles[0];
        for (int pile : piles) {
            maxPile = max(pile, maxPile);
        }
        return maxPile;
    }
    
    int max(int a, int b) {
        return (a < b) ? b : a;
    }
};
\end{lstlisting}
\noindent \textbf{Complexity Analysis:}
\begin{itemize}
    \item \textbf{Time complexity}: $\mathcal{O}(N \log M)$\\
    It takes $\mathcal{O}(\log M)$ ($M$ is the maximum number of bananas in a pile) steps to find $K$ in the search space $[1, M]$. For each iteration, it takes $\mathcal{O}(N)$ to check all piles to see whether Koko can finishe eating. Additionally, it takes $\mathcal{O}(N)$ to find the maximum number of bananas in a pile. So the total time complexity is $\mathcal{O}(N \log M) = \mathcal{O}(N \log M) + \mathcal{O}(N)$.
    \item \textbf{Space complexity}: $\mathcal{O}(1)$ \\
    Only use several variables for binary search and computation.
\end{itemize}




\end{document}